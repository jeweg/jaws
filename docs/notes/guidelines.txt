Things I'd like to play with here:

* automatic code formatting all the way. no manually drawing ascii art.

* explore and exploit return value optimization to replace the some in-out or out parameters

* vcpkg

* catch over googletest? (catch2 on vcpkg)
     -> after some research and consideration, I think I'll stick with googletest.

* benchmarks (google benchmark?)
    -> after consideration: use celero
    See comparison here:https://www.bfilipek.com/2016/01/micro-benchmarking-libraries-for-c.html#comparison 
    I have doubts that google benchmark on Windows is mature, plus celero is on vcpkg.
    So celero it is for now.
    See this discussion about cpu performance scaling when benchmarking (big gotcha):
    https://github.com/DigitalInBlue/Celero/issues/111
    
* guideline support library (vcpkg has it)

* association by string.
    -> gives us a name for debugging
    -> facilitates data-driven configuration (whether we do that is another question)
    hashed string, at compile time or run time.
    put originals in string registry that can be omitted in non-debug builds.
    
*  resource updates as commands

* Modern CMake:
    - compile features specification
    - export config
    - cotire for unity builds and pch

* Boost:
    Feel free to use boost internally.
    I'd like to not require it in the public API. FOR NOW: I'll use it occasionally even in
    the API (e.g. boost/current_function.hpp), but the plan is to replace those things with
    minimal copies. I'd just like to not introduce too much code bloat in my code at this time.

* Abseil

* Typed enums with bitfield support
    Look at https://github.com/KhronosGroup/Vulkan-Hpp for inspiration.

* Vulkan bindings: vulkan-hpp looks excellent.
  Note here: I've tried to use its no-exceptions mode for a while. The code pattern
  std::tie(result, output) = vk::... is not paintful to write and I liked it. It's definitly
  a thing we might want to imitate if given a similar problem.
  However, in vulkan-hpp it doesn't seem to work properly with ts UniqueXXX RAII classes.
  The result template doesn't support moving the contents properly so std::tie will not work.
  Since those RAII classes seem just too useful (I'd just reinvent them anyway) I enabled
  exceptions in vulkan-hpp again. Let's see how it works out for me. Obviously I don't want to
  leak those exceptions across the boundaries of the future vulkan backend.

=============================================================================================
Guidelines

* I want to support unity builds right from the start.
    anonymous namespaces are nice, but not compatible with unity builds.
    => no anonymous namespaces! use unique namespace names.

    What do we do instead of anonymous namespaces?
    classic "static" declaration limits to the whole implementation file, but that
    cn grow arbitrarily with unity builds. 

    We can use a "details" namespace as a place for non-public-API stuff,
    but that does nothing for the kind of isolation anonymous namespaces are meant for.
    That leaves us with either prefixed names or namespaces with unique names (with no
    "using namespace" directive).
    The latter is strictly more powerful than the former.

    Also, as a general rule:
    => no impl-unit-global "using" directives/declarations!

* Naming: TODO

* No exceptions if I can help it. We use error codes.
  See vulkan-hpp exception. Pun intended.

=============================================================================================
Notes

cotire.cmake would not work without this PR:
https://github.com/sakra/cotire/pull/155/commits

On the fence about calling stringify functions "to_string" -- a strong pro is that those then can be used
interchangably with std::to_string; but you have to know what you're doing, i.e. not using std::to_string, but
unqualified call to to_string with std::to_string imported into the current namespace via "using".

#include <xxx> vs "xxx": stackoverflow seems to say "" is canonical for code in files (header files). When using <>,
the code may not actually exists in files, but e.g. built into the compiler. This is theory, though, in practice
all includes point to files, but let's be nice and use "".

=============================================================================================
Lessons learned

from svkit:
I've run several times into the problem that the materials can't do enough or don't have enough information.
For instance they wanted to set defines (and hence switch to another compiled shader), know how many line
segments (for a line material, obviously) are rendered in the draw call.
There should be some level of abstraction where the code may just set and switch state however it wants and the
engine must take care of handling that optimally.
However, this shouldn't be done without limits. there must also be hints given to the engine to some extent.

string_view in the lib interface: problematic! abseil falls back to std::string_view if available
(i.e. c++17 and up) -- this means the language version of library builder and library user must match. I cannot guarantee that.

=============================================================================================
hashing

https://aras-p.info/blog/2016/08/02/Hash-Functions-all-the-way-down/
convinced me to try xxhash.
I decided against the xxhash provided by vcpkg, because that way we cannot get the
inline-all variant which includes the .c file in the .h file (the .c file is not 
present in that case). I want to be able to do that, so I include the source directly.
license is bsd.

=============================================================================================
References

